---
description: 3장-알고리즘, 정수, 행렬에 관한 내용을 정리한 문서이다.
icon: square
---

# 3. The Fundamentals: Algorithms, the Integers and Matrices

## 3.1. Algorithms

Algorithm은 9세기 수학자 al-Khowarizmi에서 유래되었다.\
al-Khowarizmi는 힌두 숫자, 현대 10진법의 기초를 다진 수학자이다.\
Decimal notation을 Algorithm이라고 하였으나 현재에는 Solving problem의 Procedure로 사용한다.\
즉, Algorithm은 계산을 수행하거나 문제를 해결하기 위한 정밀한 지침의 Finite set이다.

Computer language를 통해서 Algorithm을 설명 가능하나 해당 Language의 Instruction만 사용 가능하다.\
대신에 Pseudocode를 통해 Algorithm을 설명한다면 Programming language와 Natural language로 설명하는 것의 중간 단계가 되어 유용하게 활용할 수 있다.

{% hint style="success" %}
Example of Pesudocode

Algorithm : Finding the Maximum Elemet in a Finite Sequence

procedure $$max$$($$a_1,a_2,\cdots,a_n$$: integers)\
$$max$$ := $$a_1$$\
for $$i$$ := 2 to $$n$$\
&#x20;   if $$max$$ < $$a_i$$ then $$max$$ := $$a_i$$\
($$max$$ is the largest element)
{% endhint %}

Algorithm은 여러 Property가 존재한다.

* Input: Algorithm은 특정 Set에서 Input value를 받는다.
* Output: 각 Input value set에서 지정된 Output value를 생성한다.
* Definiteness: Algorithm의 Step은 정확하게 정의되어야 한다.
* Correctness: Algorithm은 주어진 Set의 모든 Input에 대해 Finite step 후 원하는 Output을 생성해야 한다.
* Effectiveness: Algorithm의 각 Step을 정확히 수행 가능해야 하며 Finite time 내에 이루어져야 한다.
* Generality: Procedure는 특정 Input value set에 국한되지 않고 원하는 모든 form의 Problem에 적용 가능해야 한다.

### Searching Algorithms

Ordered list에서 Element를 찾는 Problem을 Searching problem이라고 한다.\
일반적으로 서로 다른 Element로 이루어진 List에서 Element $$x$$를 찾거나 List에 없음을 확인한다.\
즉 Output은 List 내에 존재할 경우 Position value를, 그렇지 않다면 Minimum position value - 1을 반환한다.

#### Linear Search

Linear search(=Sequential search)의 경우 $$x$$와 각 List의 Element $$a_i$$를 비교한다.\
$$x=a_i$$일 경우 Solution은 $$i$$, 그렇지 않을 경우 다음 Element를 반복하여 확인한다.\
끝까지 $$x$$를 찾지 못했을 경우 Solution은 Minimum position이 이 환경에서 1로 정의되었기에 0이다.

{% hint style="info" %}
Pseudocode

Algorithm: The Linear Search Algorith

procedure $$linear\ search$$($$x$$: integer, $$a_1,a_2,\cdots,a_n$$: Distinct integers)\
$$i$$ := 1\
while($$i\leq n$$ and $$x\not=a_i$$)\
&#x20;   $$i$$ := $$i+1$$\
if $$i\leq n$$ then $$location$$ := $$i$$\
else $$location$$ := 0\
{$$location$$ is the subscript of the term that equals $$x$$, or is 0 if $$x$$ is not found}
{% endhint %}

#### Binary Search

Binary search의 경우 Ordered list에서 찾고자 하는 Element $$x$$를 List의 Middle term과 비교하여 같다면 $$x$$의 Position을, 그렇지 않다면 적절한 범위의 분리된 Sublist에서 해당 동작을 반복한다.

{% hint style="info" %}
Pseudocode

Algorithm: The Binary Search Algorithm

procedure $$binary\ search$$($$x$$: integer, $$a_1,a_2,\cdots,a_n$$: increasing integers)\
$$i$$ := 1 {$$i$$ is left endpoint of search interval}\
$$j$$ := $$n$$ {$$j$$ is right endpoint of search interval}\
while $$i$$ < $$j$$\
begin\
&#x20;   $$m$$ := ($$i+j$$)/2\
&#x20;   if $$x>a_m$$ then $$i$$ := $$m+1$$\
&#x20;   else $$j$$ := $$m$$\
end\
if $$x=a_i$$ then $$location$$ := $$i$$\
else $$location$$ := 0\
{$$location$$ is the subscript of the term equal to x, or 0 if is not found}
{% endhint %}

### Sorting Algorithms

어떤 Set의 Element list를 Sorting하는 것은 Element들을 오름차순으로 나열하는 것이다.

#### Bubble Sort

Bubble sort는 가장 간단하나 효율적이지 않은 Sortirng algorithm이다.\
인접한 Element들을 차례로 비교해 조건에 맞게 교환하며 Sorting한다.

{% hint style="info" %}
Pseudocode

Algorithm: The Bubble Sort

procedure $$bubble\ sort$$($$a_1,a_2,\cdots,a_n$$: real numbers with $$n\geq 2$$)\
for $$i$$ := 1 to $$n-1$$\
&#x20;   for $$j$$ := 1 to $$n-i$$\
&#x20;       if $$a_j>a_{j+1}$$ then interchange $$a_j$$ and $$a_{j+1}$$\
{$$a_1, \cdots, a_n$$ is in increasing order}
{% endhint %}

#### Insertion Sort

Insertion sort는 간단한 Sorting algorithm이나 효율적이지 않다.\
$$n$$개의 Element로 이루어진 List를 정렬하기 위해 Linear search를 반복한다.

{% hint style="info" %}
Pseudocode

Algorithm: The Insertion Sort

procedure $$insertion\ sort$$($$a_1,\cdots,a_n$$: real numbers with $$n\geq 2$$)\
for $$i$$ := 2 to $$n$$\
begin\
&#x20;   $$j$$ := $$i$$\
&#x20;   while $$a_j>a_i$$\
&#x20;        $$j$$ := $$j+1$$\
&#x20;   for $$k$$ := 0 to $$j-i-1$$\
&#x20;       $$a_{j-k}$$ := $$a_{j-k-1}$$\
&#x20;   $$a_i$$ := $$m$$\
end\
{$$a_1,\cdots,a_n$$ are sorted}
{% endhint %}

### Greedy Algorithm

Greedy algorithm은 최적화하는 데 사용하여 각 Step의 최선의 선택을 수행한다.

{% hint style="info" %}
Pseudocode

Algorithm: Greedy Change-Making Algorithm

procedure $$change$$($$c_1,\cdots,c_r$$: values of denominations of coins, where $$c_1>\cdots >c_r$$; $$n$$, a positive integer)\
for $$i$$ := 1 to $$r$$\
&#x20;   while $$n\geq c_i$$\
&#x20;   begin\
&#x20;       add a coin with value $$c_i$$ to the change\
&#x20;       $$n$$ := $$n-c_i$$\
&#x20;   end
{% endhint %}

### The Halting Problem

Computer program과 Program에 대한 Input을 받고 주어진 Input으로 실행할 때 Program이 멈출 지(Not infinite loop)에 대한 여부를 판별하는 것이 Halting problem이다.

Alan Turing이 위 Halting problem의 Procedure가 존재하지 않음을 증명하였다.\
Program이 종료되지 않았을 때 이후 해결될 것인지, 결코 정지하지 않을 지 알 수 없다.\
Procedure가 무엇인 지 명시적으로 정의하지 않았기 때문이다.

<figure><img src="https://lh7-rt.googleusercontent.com/slidesz/AGV_vUfxpk8j4RaGBhHQVtZNX8Xr0YjJmoTjTYZ6Xl5CITe5Y0TQkzGu1Ms4h7YGFWrJeoi6zKCJmtJ_cKvgcIJc-JtzTRAF5GbJR-9wQnPefjIpQgrjPtM_DgDGQUZ3RCB8SLCc4eZIpw=s2048?key=1gyYxAsNuETRKG7aPNK0CnIz" alt=""><figcaption><p>The halting problem</p></figcaption></figure>

Procedure $$H(P,I)$$는 Program $$P$$가 $$I$$라는 Input을 받고 실행이 끝나면 True, 그렇지 않을 경우 False를 반환한다고 가정할 때 Subroutine $$T$$를 아래와 같이 가정한다.\
function $$T$$($$P$$: Halting problem을 판단할 Code)\
&#x20;   if $$H(P,P)$$ = false\
&#x20;       return true\
&#x20;   else\
&#x20;       loop forever

위와 같이 가정하였을 때 $$T(P)$$가 True를 반환한다면 $$H(P,P)$$가 False이나 $$T(P)$$는 Infinite loop를, $$T(P)$$가 Infinite loop에 빠진다면 $$H(P,P)$$가 True를 반환하는 Contradiction 발생으로 Halting problem을 해결할 수 있는 Algorithm은 존재하지 않음을 증명할 수 있다.

## 3.2. The Growth of Functions

### Big-O Notation

Function $$f, g$$에 대해 Integer나 Real number에서 Real number로 가는 Function일 때 $$f(x)$$가 $$O(g(x))$$라고 할 때 Constant $$C, k$$가 존재하여 $$x>k$$일 때 $$|f(x)|\leq C|g(x)|$$가 성립함을 의미한다.\
위 Constant $$C, k$$를 Big-$$O$$ notation의 정의에서 $$f(x)$$가 $$O(g(x))$$의 Relationship의 Witness라고 불리며 $$O(g(x))$$임을 증명하기 위해 한 Pair의 Witnesses가 필요하다.

Witnesses pair를 찾기 위해 먼저 $$x>k$$일 때 $$|f(x)|$$의 크기를 쉽게 추정할 수 있는 $$k$$ 값을 선택한 후 $$|f(x)|<C|g(x)|$$를 성립하는 $$C$$ 값을 찾는다.\
$$f(x)$$가 $$O(g(x))$$를 $$f(x)=O(g(x))$$로 표현하나 Equaility를 표현하는 뜻은 아니다.\
명확하게 표현하기 위해 $$f(x)\in O(g(x))$$이며 $$O(g(x))$$는 여러 $$O(g(x))$$인 Function들의 Set이기 때문이다.

Big-$$O$$ notation은 Computer science에서 Algorithm 분석에 사용되며 Asymptotic notation(점근 표기법)의 하나로 Lamdau symbol이라고도 한다.

Function $$f(x)$$가 $$O(g(x))$$이고, $$h(x)$$가 충분히 큰 $$x$$ Value에 대해 $$g(x)$$보다 절대값이 더 큰 Function을 의미한다면 $$f(x)$$는 $$O(h(x)), g(x)$$는 절대값이 더 큰 Function으로 대체 가능하다.

$$x>k$$일 때 $$|f(x)|\leq C|g(x)|$$이고, 모든 $$x>k$$일 때 $$|h(x)|>|g(x)|$$라면, $$x>k$$일 때 $$|f(x)|\leq C|h(x)|$$, 즉, $$f(x)\in O(h(x))$$이다.

### Some Important Big-O Results

3/19















