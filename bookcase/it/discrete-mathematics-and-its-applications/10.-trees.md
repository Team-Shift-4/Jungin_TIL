---
icon: square
description: 10장-트리와 관련된 내용을 정리한 문서이다.
---

# 10. Trees

## 10.1. Introduction to Trees

Tree는 Simple circuit이 존재하지 않는 Connected undirected graph이다.

{% hint style="success" %}
Example

![](<../../../.gitbook/assets/image (3) (1).png>)\
그림 중 Tree인 Graph

* Solution\
  $$G_1, G_2$$는 Simple circuit을 가지지 않은 Connected graph이므로 Tree이다.\
  $$G_3$$의 경우 $$e,b,a,d,e$$인 Simple circuit을 가지므로 Tree가 아니고, $$G_4$$의 경우 \$$Connected graph가 아니므로 Tree가 아니다.
{% endhint %}

{% hint style="info" %}
Theorem

Undirected graph가 두 Vertex 사이에 유일한 Simple path가 존재할 때만 Tree이다.

* Solution\
  Connected simple graph이며 Circuit이 없으려면 어떠한 두 Vertex 사이에 Simple path는 단 하나만 존재할 수 있다.
{% endhint %}

Tree를 응용할 때 특정 Vertex를 Root로 지정한다.\
Root를 지정할 경우 각 Edge에 Direction을 부여할 수 있다.

Rooted tree는 하나의 Vertex가 Root로 지정되고 모든 Edge가 Root에서 멀어지도록 Direction이 지정된 Tree이다.

$$v$$가 Rooted tree의 Root가 아닌 Vertex라면 $$v$$의 Parent $$u$$는 $$v$$가 Root로의 Path를 생성할 때 $$u$$에서 $$v$$로의 Directed edge를 가진 유일한 Vertex이며 반대의 관계를 Child라고 한다.\
같은 Parent를 둔 여러 Vertex들의 관계는 Sibling이라고 한다.\
Root가 아닌 Vertex의 Ancestor는 Root에서 해당 Vertex까지의 Path에 있는 Vertex들로 Root를 포함하며 해당 Vertex는 제외한다.\
반대의 관계를 Descendant라고 한다.

Tree에서 Child가 없을 경우 Leaf라고 부르며 Root가 유일한 Vertex일 경우 Leaf, 그렇지 않을 경우 Internal vertex라고 불린다.\
만약 $$a$$가 Tree의 Vertex라면 $$a$$를 Root로 삼는 Subtree는 $$a$$와 그 Descendant들에 Adjacent인 모든 Edge로 이루어진 Tree의 Subgraph가 된다.

Internal vertex가 $$m$$보다 많은 Children을 가지지 않을 때 $$m$$-ary tree라 하고 Full $$m$$-ary tree의 경우 모든 Internal vertex가 $$m$$만큼의 Children을 가질 때이다.\
$$m=2$$일 때 Binary tree라고 부른다.

{% hint style="success" %}
Example

![](<../../../.gitbook/assets/image (2) (1) (1).png>)\
그림의 각 Graph가 Full $$m$$-ary tree인 지 확인

* Solution\
  $$T_1$$의 경우 Full binary tree, $$T_2$$의 경우 Full 3-ary tree, $$T_3$$의 경우 Full 5-ary tree, $$T_4$$의 경우 Full $$m$$-ary의 Tree가 아니며 Children 수가 $$2, 3$$ 중 하나이므로 3-ary tree이다.
{% endhint %}

Ordered rooted tree의 경우 Children들이 왼쪽에서 오른쪽으로 표시되도록 그려지며 Binary tree에서 첫 번째 Child를 Left child, 두 번째 Child를 Right child라고 부른다.\
Child를 Root 삼은 Subtree 중 Left child가 Root가 된 Subtree를 Left subtree, 반대를 Right subtree라 부른다.

{% hint style="success" %}
Example

![](<../../../.gitbook/assets/image (3) (1) (1).png>)\
그림의 $$(a)$$에 표시된 Binary tree의 $$(b), (c)$$의 관계

* Solution\
  $$(b)$$는 $$c$$의 Left subtree, $$(c)$$는 $$c$$의 Right subtree이다.
{% endhint %}

### Trees as Models

Tree를 Model로 삼는 다양한 예시가 존재한다.

{% hint style="success" %}
Simple Example

* Saturated Hydrocarbons and Trees\
  ![](<../../../.gitbook/assets/image (4) (1).png>)
* Representing Organizations\
  ![](<../../../.gitbook/assets/image (5) (1).png>)
* Computer File Systems\
  ![](<../../../.gitbook/assets/image (6).png>)
{% endhint %}

### Properties of Trees

{% hint style="info" %}
Theorem

$$n$$개의 Vertex가 있는 Tree는 $$n-1$$개의 Edge를 가진다.

* Proof\
  간단히 Mathematical induction을 사용하여 증명 가능하다.\
  Tree의 Vertex가 1개일 때 Edge는 0을 Basis step으로 삼고\
  모든 Vertex가 $$n-1$$개인 Tree의 Edge 수가 $$n-2$$개 일 때 어느 Vertex에 Child로 추가하여도 Edge는 단 1개만 증가하므로 증명 가능하다.
{% endhint %}

{% hint style="info" %}
Theorem

Full $$m$$-ary tree의 Internal vertex의 수가 $$i$$일 때 Vertex 수 $$n=mi+1$$
{% endhint %}

{% hint style="info" %}
Theorem

Full $$m$$-ary tree는

1. $$n$$개의 Vertex가 있는 경우 Internal vertex 수 $$i=(n-1)/m$$이며 Leaf의 수 $$l=[(m-1)n+1]/m$$이다.
2. $$i$$개의 Internal vertex가 있는 경우 $$n=mi+1$$개의 Vertex와 $$l=(m-1)i+1$$개의 Leaf가 존재한다.
3. $$l$$개의 Leaf가 존재하는 경우 $$n=(ml-1)/(m-1)$$개의 Vertex와 $$i=(l-1)/(m-1)$$개의 Internal vertex가 존재한다.
{% endhint %}

Blanced rooted tree를 사용할 경우 각 Vertex의 Subtree가 대략 같은 길이의 Path를 포함하도록 하기 위함이다.\
Rooted tree에서 Vertex $$v$$의 Level은 Root에서 해당 Vertex까지의 유일한 Path의 길이이다.\
Root의 Level은 0이다.\
Rooted tree의 Height는 Vertex들의 Level 중 Maximum value이다.

{% hint style="success" %}
Example

![](<../../../.gitbook/assets/image (5).png>)\
각 Vertex의 Level

* Solution\
  Root $$a= 0$$\
  $$b,j,k=1$$\
  $$c,e,f,l=2$$\
  $$d,g,i,m,n=3$$\
  $$h=4$$\
  Height가 4인 Rooted tree이다.
{% endhint %}

Height $$h$$의 Rooted $$m$$-ary tree는 모든 Leaf가 Level $$h$$, $$h-1$$에 있을 때 Balanced라고 할 수 있다.

{% hint style="success" %}
Example

![](<../../../.gitbook/assets/image (1) (1).png>)\
위 Rooted tree들이 Balanced인 지

* Solution\
  $$T_1, T_3$$는 Balanced이다. 각각 3-4, 3에 Leaf가 존재하기 때문이다.\
  $$T_2$$는\
  Not balanced이며 Leaf들의 Level이 2,3,4이기 때문이다.
{% endhint %}

{% hint style="info" %}
Theorem

Height가 $$h$$인 $$m$$-ary tree는 최대 $$m^h$$개의 Leaf들을 가질 수 있다.

* Proof\
  Full balanced $$m$$-ary tree의 경우 $$h$$Level $$lv$$에 따라 최대 $$m^{ lv}$$개의 Vertex를 추가할 수 있으므로 최대 $$m^h$$개의 Leaf들을 가질 수 있게 된다.
{% endhint %}

{% hint style="info" %}
Corollary

Height가 $$h$$인 $$m$$-ary tree에 Leaf가 $$l$$개 존재한다면 $$h\geq \lceil \log_m l\rceil$$이며, $$m$$-ary tree가 Full and balanced이면 $$h=\lceil \log_ml\rceil$$이다.

* Proof\
  앞전 Theorem의 역치로 증명할 수 있다.
{% endhint %}

## 10.2. Applications of Trees

### Binary Search Trees

{% hint style="info" %}
Pseudocode

Algorithm Locating and Adding Items to a Binary Search Tree

procedure $$insertion$$($$T$$: binary search tree, $$x$$: item)\
$$v$$ := root of $$T$${a vertex not present in $$T$$ has the value $$null$$}\
while $$v\not= null$$ and $$label(v)\not= x$$\
begin\
&#x20;   if $$x<label(v)$$ then\
&#x20;       if left chilid of $$v\not= null$$ then $$v$$ := left child of $$v$$\
&#x20;       else add $$new\ vertex$$ as a right child of $$v$$ to $$T$$ and set $$v$$ := $$null$$\
&#x20;   else\
&#x20;       if right child of $$v\not= null$$ then $$v$$ := right child of $$v$$\
&#x20;       else add $$new\ vertex$$ as a right child of $$v$$ to $$T$$ and set $$v$$ := $$null$$\
end\
if root of $$T=null$$ then add a vertex $$v$$ to the tree and label it with $$x$$\
else if $$v$$ is $$null$$ or $$label(v)\not = x$$ then label $$new\ vertex$$ with $$x$$ and let $$v$$ be this new vertex {$$v$$= location of $$x$$}
{% endhint %}

### Decision Trees

Rooted tree는 일련의 Decision을 통해 Solution에 도달하는 Problem을 모델링 하는 데 사용될 수 있다.\
예시로 위에서 다룬 Binary search tree의 경우 일련의 비교를 기반으로 원하는 Item을 찾는 데 사용할 수 있으며, 각 비교는 Item을 찾았는 지, Subtree에서 오른쪽 또는 왼쪽으로 가야하는 지를 알 수 있다.\
각 Interior vertex가 Dicision에 해당하고 이 Vertex에서 각 가능한 Dicision Result에 대한 Subtree가 있는 Rooted tree를 Decision tree라고 한다.

{% hint style="success" %}
Example

List $$a, b, c$$ 를 정렬하는 Decision tree

![](<../../../.gitbook/assets/image (2) (1).png>)
{% endhint %}

{% hint style="info" %}
Theorem

Binary comparison에 기반한 Sorting algorithm은 최소한 $$\lceil \log n!\rceil$$의 Comparison이 필요하다.
{% endhint %}

{% hint style="info" %}
Corollary

Binary comparison에 기반한 Sorting algorithm이 $$n$$개의 Element를 정렬하는 데 사용하는 Comparison 횟수는 $$\Theta(n \log n)$$이다.
{% endhint %}

{% hint style="info" %}
Theorem

Binary comparison에 가반한 Sorting algorithm이 $$n$$개의 Element를 정렬하는 데 사용하는 Comparison의 평균은 $$\Omega(n \log n)$$이다.
{% endhint %}

### Prefix Codes

Bit string을 이용하여 Alphabet 글자를 Incoding하는 방법을 고려할 때 총 26개의 글자가 존재하기에 최소 5 Bit string으로 표현해야 하나 이보다 더 효율적인 방법이 있는 지 고려해볼 수 있다.\
이 때 가변 길이 Bit string을 쓴다면 자주 발생하는 글자는 짧은 Bit string으로, 드물게 발생하는 글자는 비교적 더 긴 Bit string으로 Incoding할 수 있다.\
예시로 e, a, t를 각각 0, 1, 01로 Incoding 할 수 있으며 이 때 Bit string 0101은 eat, tea, eaea, tt 등으로 해당할 수 있다.

위 예시와 같이 하나의 Bit string이 여러 글자 Sequence에 해당하지 않도록 보장하여야 사용 가능한데, 이 때 하나의 글자를 Incoding할 때 한 글자의 Bit string이 다른 글자의 Bit string의 첫 부분으로 나타나지 않게 하는 것이다.\
이를 Prefix code라고 한다.\
e, a, t를 0, 10, 11로 각각 Incoding 하였을 때 Bit string 10110은 ate만이 될 수 있다.

Prefix code는 Binary tree를 사용하여 표현할 수 있으며 이 Tree의 Leaf에 글자가 Label로 달려 있다.\
Tree의 Edge는 Left child로 갈 때 0, Right child로 갈 때 1을 할당해 Label을 붙인다.\
특정 Bit string을 Incoding하는 Bit string은 root에서 해당 글자가 Label로 붙은 Leaf까지의 고유한 Path에서 Edge의 Label로 구성된 Sequence이다.

Huffman Coding은 Symbol의 빈도를 Input으로 받아 가능한 적은 Bit를 사용하여 String을 Incoding하는 Prefix를 출력하는 Algorithm이다.\
Huffman coding은 Data compression의 Fundamental algorithm이다.

간단히 요약하여 Huffman coding은 Rooted tree의 Root에서 Leaf까지의 Path가 유일하게 Item을 구분 할 수 있게 해줌을 이용하여, 사용 빈도가 높은 Item을 짧은 Path에, 그렇지 않은 Item을 비교적 긴 Path에 놓아 효율을 중시한 기법이다.

{% hint style="info" %}
Pseudocode

Algorithm Huffman Coding

procedure $$Huffman$$($$C$$: symbol $$a_i$$ with frequencies $$w_i$$, $$i=1,\dots,n$$)\
$$F$$ := forest of $$n$$ rooted trees, each consisting of the single vertex $$a_i$$ and assigned weight $$w_i$$\
while $$F$$ is not a tree\
begin\
&#x20;   Replace the rooted trees $$T$$ and $$T'$$ of least weights from $$F$$ with $$w(T)\geq w(T')$$ with a tree having a new root that has $$T$$ as its left subtree and $$T'$$ as its right subtree. Label the new edge to $$T$$ with 0 and the new edge to $$T'$$ with 1. Assign $$w(T)+w(T')$$ as the weight of the new tree\
end\
{the Huffman coding for the symbol $$a_i$$ is the concatenation of the labels of the edges in the unique path from the root to the vertex $$a_i$$}
{% endhint %}

{% hint style="success" %}
Example

Huffman coding을 사용하여 다음 Symbol을 주어진 Frequency로 Incoding\
A: 0.08, B: 0.10, C: 0.12, D: 0.15, E: 0.20, F: 0.35

* Solution\
  ![](<../../../.gitbook/assets/image (2).png>)\
  위 과정에 의해 A=111, B=110, C=011, D=010, E=10, F=00으로 Incoding하였다.
{% endhint %}

### Game Trees

Game tree는 Tic-tac-toe, Nim, Checker, Chess와 같이 Player들이 번갈아 가며 각 상황의 수(우연 요소 없이)를 두는 것을 의미한다.

Game tree의 Vertex의 Value는 Recursive하게 Define할 수 있다.

1. Leaf의 Value는 Game이 이 Leaf로 나타내는 위치에서 종료될 때 첫 번째 Player에게 지급되는 보상이다.
2. 짝수 Level의 Interior vertex의 Value는 Children 중 Maximum이며 홀수 Level의 Interior vertex의 Value는 Children 중 Minimum이다.

{% hint style="info" %}
Theorem

Game tree의 Vertex의 Value는 두 Player가 Minmax strategy를 따르고 이 Vertex로 부터 Player가 시작될 때 첫 번째 Player에게 지급되는 보상이다.

* Proof\
  Induction을 사용하여 Theorem의 증명과 추가 설명을 할 수 있다.\
  Basis step: 만약 Vertex가 Leaf인 경우 Theorem에 따라 이 Vertex에 할당된 가치는 첫 번째 Player에게 지급되는 보상이다.\
  Inductive step: Vertex의 Children의 Value가 각 Vertex가 나타내는 위치에서 Play가 시작될 때 첫 번째 Player에게 지급되는 보상이다.\
  즉 이 때 두 가지 상황이 발생하는데, 첫 번째 Player냐 두 번째 Player냐의 상황이다.\
  첫 번째 Player의 상황에는 각 Vertex에서 Maximum value를 선택하는 것이 첫 번째 Player에게 유리한 상황이 되고, 두 번째 Player의 상황에는 각 Vertex에서 Minimum value를 선택하여 첫 번째 Player의 이득을 줄이는 것이 이득이 된다.
{% endhint %}

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption><p>Nim</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption><p>Tic-tac-toe</p></figcaption></figure>

## 10.3. Tree Traversal

### Universal Address Systems













